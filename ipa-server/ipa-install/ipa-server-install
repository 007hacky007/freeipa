#! /usr/bin/python -E
# Authors: Karl MacMillan <kmacmillan@mentalrootkit.com>
#
# Copyright (C) 2007  Red Hat
# see file 'COPYING' for use and warranty information
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2 only
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#


# requires the following packages:
# fedora-ds-base
# openldap-clients
# nss-tools

VERSION = "%prog .1"

import sys
sys.path.append("/usr/share/ipa")

import os
import socket
import errno
import logging
import pwd
import getpass
import subprocess
import signal
import shutil
import glob
from optparse import OptionParser
import ipaserver.dsinstance
import ipaserver.krbinstance
import ipaserver.bindinstance
import ipaserver.httpinstance
from ipa.ipautil import run

def parse_options():
    parser = OptionParser(version=VERSION)
    parser.add_option("-u", "--user", dest="ds_user",
                      help="ds user")
    parser.add_option("-r", "--realm", dest="realm_name",
                      help="realm name")
    parser.add_option("-p", "--ds-password", dest="dm_password",
                      help="admin password")
    parser.add_option("-P", "--master-password", dest="master_password",
                      help="kerberos master password")
    parser.add_option("-a", "--admin-password", dest="admin_password",
                      help="admin user kerberos password")
    parser.add_option("-d", "--debug", dest="debug", action="store_true",
                      default=False, help="print debugging information")
    parser.add_option("--hostname", dest="host_name", help="fully qualified name of server")
    parser.add_option("--ip-address", dest="ip_address", help="Master Server IP Address")
    parser.add_option("--setup-bind", dest="setup_bind", action="store_true",
                      default=False, help="configure bind with our zone file")
    parser.add_option("-U", "--unattended", dest="unattended", action="store_true",
                      default=False, help="unattended installation never prompts the user")

    options, args = parser.parse_args()

    if options.unattended and (not options.ds_user or
                               not options.realm_name or
                               not options.dm_password or
                               not options.admin_password or
                               not options.master_password):
        parser.error("error: In unattended mode you need to provide at least -u, -r, -p and -P options")

    return options

def logging_setup(options):
    # Always log everything (i.e., DEBUG) to the log
    # file.
    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s %(levelname)s %(message)s',
                        filename='ipaserver-install.log',
                        filemode='w')

    console = logging.StreamHandler()
    # If the debug option is set, also log debug messages to the console
    if options.debug:
        console.setLevel(logging.DEBUG)
    else:
        # Otherwise, log critical and error messages
        console.setLevel(logging.ERROR)
    formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')
    console.setFormatter(formatter)
    logging.getLogger('').addHandler(console)

def erase_ds_instance_data(serverid):
    try:
        shutil.rmtree("/etc/dirsrv/slapd-%s" % serverid)
    except:
        pass
    try:
        shutil.rmtree("/var/lib/dirsrv/slapd-%s" % serverid)
    except:
        pass
    try:
        shutil.rmtree("/var/lock/dirsrv/slapd-%s" % serverid)
    except:
        pass

def signal_handler(signum, frame):
    global ds
    print "\nCleaning up..."
    if ds:
        print "Removing configuration for %s instance" % ds.serverid
        ds.stop()
        if ds.serverid:
            erase_ds_instance_data (ds.serverid)
    sys.exit(1)

def check_existing_installation():
    dirs = glob.glob("/etc/dirsrv/slapd-*")
    if not dirs:
        return
    print ""
    print "An existing Directory Server has been detected."
    yesno = raw_input("Do you wish to remove it and create a new one? [no]: ")
    if not yesno or yesno.lower()[0] != "y":
        sys.exit(1)

    try:
        run(["/sbin/service", "dirsrv", "stop"])
    except:
        pass
    for d in dirs:
        serverid = os.path.basename(d).split("slapd-", 1)[1]
        if serverid:
            erase_ds_instance_data(serverid)

def check_ports():
    ds_unsecure = port_available(389)
    ds_secure = port_available(636)
    if not ds_unsecure or not ds_secure:
        print "IPA requires ports 389 and 636 for the Directory Server."
        print "These are currently in use:"
        if not ds_unsecure:
            print "\t389"
        if not ds_secure:
            print "\t636"
        sys.exit(1)

def get_fqdn():
    fqdn = ""
    try:
        fqdn = socket.getfqdn()
    except:
        try:
            fqdn = socket.gethostname()
        except:
            fqdn = ""
    return fqdn
   
def verify_fqdn(host_name):
    is_ok = True
    if len(host_name.split(".")) < 2 or host_name == "localhost.localdomain":
        print "Invalid hostname: " + host_name
        print "This host name can't be used as a hostname for an IPA Server"
        is_ok = False
    return is_ok

def read_host_name(host_default):
    host_ok = False
    host_name = ""

    print "Enter the fully qualified domain name of the computer"
    print "on which you're setting up server software. Using the form"
    print "<hostname>.<domainname>"
    print "Example: master.example.com."
    print ""
    print ""
    if host_default == "":
        host_default = "master.example.com"
    while not host_ok:
        host_input = raw_input("Server host name [" + host_default + "]: ")
        print ""
        if host_input == "":
            host_name = host_default
        else:
            host_name = host_input
        if not verify_fqdn(host_name):
            host_name = ""
            continue
        else:
            host_ok = True
    return host_name

def resolve_host(host_name):
    ip = ""
    try:
        ip = socket.gethostbyname(host_name)

        if ip == "127.0.0.1" or ip == "::1":
            print "The hostname resolves to the localhost address (127.0.0.1/::1)"
            print "Please change your /etc/hosts file so that the hostname"
            print "resolves to the ip address of your network interface."
            print "The KDC service does not listen on localhost"
            print ""
            print "Please fix your /etc/hosts file and restart the setup program"
            return "-Fatal Error-"

    except:
        print "Unable to lookup the IP address of the provided host"
    return ip

def verify_ip_address(ip):
    is_ok = True
    try:
        socket.inet_pton(socket.AF_INET, ip)
    except:
        try:
            socket.inet_pton(socket.AF_INET6, ip)
        except:
            print "Unable to verify IP address"
            is_ok = False
    return is_ok

def read_ip_address():
    askip = True
    while askip:
        ip = raw_input("Please provide the IP address to be used for this host name: ")

        if ip == "":
            continue
        if ip == "127.0.0.1" or ip == "::1":
            print "The IPA Server can't use localhost as a valid IP"
            continue

        if not verify_ip_address(ip):
            continue

        print "Adding ["+ip+" "+host_name+"] to your /etc/hosts file"
        hosts_fd = open('/etc/hosts', 'r+')
        hosts_fd.seek(0, 2)
        hosts_fd.write(ip+'\t'+host_name+' '+host_name[:host_name.find('.')]+'\n')
        hosts_fd.close()
        askip = False

def port_available(port):
    """Try to bind to a port on the wildcard host
       Return 1 if the port is available
       Return 0 if the port is in use
    """
    rv = 1

    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind(('', port))
        s.shutdown(0)
        s.close()
    except socket.error, e:
        if e[0] == errno.EADDRINUSE:
            rv = 0

    if rv:
        try:
            s = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            s.bind(('', port))
            s.shutdown(0)
            s.close()
        except socket.error, e:
            if e[0] == errno.EADDRINUSE:
                rv = 0

    return rv

def read_ds_user():
    print "The server must run as a specific user in a specific group."
    print "It is strongly recommended that this user should have no privileges"
    print "on the computer (i.e. a non-root user).  The setup procedure"
    print "will give this user/group some permissions in specific paths/files"
    print "to perform server-specific operations."
    print ""
    
    ds_user = ""
    try:
        pwd.getpwnam('dirsrv')

        print "A user account named 'dirsrv' already exists."
        print ""
        yesno = raw_input("Do you want to use the existing 'dirsrv' account? [yes]: ")
        print ""
        if not yesno or yesno.lower()[0] != "n":
            ds_user = "dirsrv"
        else:
            ds_user = raw_input("Which account name do you want to use for the DS instance? ")
            print ""
    except KeyError:
        ds_user = "dirsrv"

    return ds_user

def read_realm_name(domain_name):
    print "The kerberos protocol requires a Realm name to be defined."
    print "This is typically the domain name converted to uppercase."
    print ""
    upper_dom = domain_name.upper()
    realm_name = raw_input("Please provide a realm name ["+upper_dom+"]: ")
    print ""
    if realm_name == "":
        realm_name = upper_dom
    else:
        upper_dom = realm_name.upper()
    if upper_dom != realm_name:
        print "It is strongly recommended that you use a completely uppercased name for the realm."
        dom_realm = raw_input("Do you want to use "+upper_dom+" as realm name ? [yes]: ")
        print ""
        if dom_realm and dom_realm.lower()[0] != "y":
            print "WARNING: Using a non upper-cased realm name may cause unexpected problems."
        else:
            realm_name = upper_dom
    return realm_name

def read_password(user):
    correct = False
    pwd = ""
    while not correct:
        pwd = getpass.getpass(user + " password: ")
        if not pwd:
            continue
        pwd_confirm = getpass.getpass("Password (confirm): ")
        if pwd != pwd_confirm:
            print "Password mismatch!"
            print ""
        else:
            correct = True
        #TODO: check validity/length
    print ""
    return pwd

def read_dm_password():
    print "Certain directory server operations require an administrative user."
    print "This user is referred to as the Directory Manager and has full access"
    print "to the Directory for system management tasks."
    print "The password must be at least 8 characters long, and contain no spaces."
    print ""
    #TODO: provide the option of generating a random password
    dm_password = read_password("Directory Manager")
    return dm_password

def read_master_password():
    print "The Kerberos database is usually encrypted using a master password."
    print "Please store this password offline in a secure place."
    print "It may be necessary in a recovery situation or to install a replica."
    print "Without the master password the encrypted material can't be used by the KDC."
    print "If the master password is lost all kerberos related secrets will also be lost."
    print ""
    #TODO: provide the option of generating a random password
    master_password = read_password("Kerberos master")
    return master_password

def read_admin_password():
    print "The IPA server requires an administrative user, named 'admin'."
    print "This user is a regular system account used for IPA server administration."
    print ""
    #TODO: provide the option of generating a random password
    admin_password = read_password("IPA admin")
    return admin_password

def main():
    global ds
    ds = None
    
    if os.getegid() != 0:
        print "Must be root to setup server"
        return
    
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    print "=============================================================================="
    print "This program will setup the FreeIPA Server."
    print ""
    print "To accept the default shown in brackets, press the Enter key."
    print ""

    check_existing_installation()
    check_ports()

    options = parse_options()
    logging_setup(options)

    ds_user = ""
    realm_name = ""
    host_name = ""
    domain_name = ""
    ip_address = ""
    master_password = ""
    dm_password = ""
    admin_password = ""

    # check bind packages are installed
    bind = ipaserver.bindinstance.BindInstance()
    if options.setup_bind:
        if not bind.check_inst():
            print "--setup-bind was specified but bind is not installed on the system"
            print "Please install bind (you also need the package 'caching-nameserver') and restart the setup program"
            return "-Fatal Error-"

    # check the hostname is correctly configured, it must be as the kldap
    # utilities just use the hostname as returned by gethostbyname to set
    # up some of the standard entries

    host_default = ""
    if options.host_name:
        host_default = options.host_name
    else:
        host_default = get_fqdn()
        
    if options.unattended:
        if not verify_fqdn(host_default):
            return "-Fatal Error-"
        else:
            host_name = host_default
    else:
        host_name = read_host_name(host_default)
    
    domain_name = host_name[host_name.find(".")+1:]

    # Check we have a public IP that is associated with the hostname
    ip = resolve_host(host_name)
    if not ip:
        if options.ip_address:
            ip = options.ip_address
    if not ip and options.unattended:
        print "Unable to resolve IP address for host name"
        return "-Fatal Error-"

    if not verify_ip_address(ip):
        ip = ""
        if options.unattended:
            return "-Fatal Error-"

    if options.ip_address and options.ip_address != ip:
        if options.setup_bind:
            ip = options.ip_address
        else:
            print "Error: the hostname resolves to an IP address that is different"
            print "from the one provided on the command line.  Please fix your DNS"
            print "or /etc/hosts file and restart the installation."
            return "-Fatal Error-"
 
    if options.unattended:
        if not ip:
            print "Unable to resolve IP address"
            return "-Fatal Error-"

    if not ip:
        ip = read_ip_address ()
    ip_address = ip

    print "The IPA Master Server will be configured with"
    print "Hostname:    " + host_name
    print "IP address:  " + ip_address
    print "Domain name: " + domain_name
    print ""

    if not options.ds_user:
        ds_user = read_ds_user()
        if ds_user == "":
            return "-Aborted-"
    else:
        ds_user = options.ds_user

    if not options.realm_name:
        realm_name = read_realm_name(domain_name)
    else:
        realm_name = options.realm_name

    if not options.dm_password:
        dm_password = read_dm_password()
    else:
        dm_password = options.dm_password

    if not options.master_password:
        master_password = read_master_password()
    else:
        master_password = options.master_password

    if not options.admin_password:
        admin_password = read_admin_password()
    else:
        admin_password = options.admin_password

    if not options.unattended:
        print ""
        print "The following operations may take some minutes to complete."
        print "Please wait until the prompt is returned."

    # Create a directory server instance
    ds = ipaserver.dsinstance.DsInstance()
    ds.create_instance(ds_user, realm_name, host_name, dm_password)

    # Create a kerberos instance
    krb = ipaserver.krbinstance.KrbInstance()
    krb.create_instance(ds_user, realm_name, host_name, dm_password, master_password)

    # Create a HTTP instance
    http = ipaserver.httpinstance.HTTPInstance()
    http.create_instance()

    bind.setup(host_name, ip_address, realm_name)
    if options.setup_bind:
        skipbind = False
        if not options.unattended:
            print "This program is about to replace the DNS Server configuration,"
            print "with an automatically generated one, based on the data gathered so far."
            print "This will REPLACE any existing configuration."
            yesno = raw_input("Are you sure you want to configure the DNS Server ? [no]: ")
            if not yesno or yesno.lower()[0] != 'y':
                skipbind = True
        if not skipbind:
            bind.create_instance()
    else:
        bind.create_sample_bind_zone()

    # Restart ds and krb after configurations have been changed
    ds.restart()
    krb.restart()

    try:
        selinux=0
        try:
            if (os.path.exists('/usr/sbin/selinuxenabled')):
                run(["/usr/sbin/selinuxenabled"])
                selinux=1
        except subprocess.CalledProcessError, e:
            # selinuxenabled returns 1 if not enabled
            pass

        if selinux:
            # Allow apache to connect to the turbogears web gui
            run(["/usr/sbin/setsebool", "-P", "httpd_can_network_connect", "true"])

        # Start the web gui
        run(["/sbin/service", "ipa-webgui", "start"])

        # Set the web gui to start on boot
        run(["/sbin/chkconfig", "ipa-webgui", "on"])

        # Restart apache
        run(["/sbin/service", "httpd", "restart"])

        # Set apache to start on boot
        run(["/sbin/chkconfig", "httpd", "on"])

        # Set fedora-ds to start on boot
        run(["/sbin/chkconfig", "dirsrv", "on"])

        # Set the KDC to start on boot
        run(["/sbin/chkconfig", "krb5kdc", "on"])

        # Set the Kpasswd to start on boot
        run(["/sbin/chkconfig", "ipa-kpasswd", "on"])

        # Start Kpasswd
        run(["/sbin/service", "ipa-kpasswd", "start"])
    except subprocess.CalledProcessError, e:
        print "Installation failed:", e
        return 1

    # Set the admin user kerberos password
    ds.change_admin_password(admin_password)

    # Create the config file
    fd = open("/etc/ipa/ipa.conf", "w")
    fd.write("[defaults]\n")
    fd.write("server=" + host_name + "\n")
    fd.write("realm=" + realm_name + "\n")
    fd.close()

    return 0

try:
    main()
except Exception, e:
    print "Unexpected error - see ipaserver-install.log for details:\n %s" % str(e)
